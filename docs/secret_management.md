# Secret Management Solutions for Microservices ## Open Source Docker Images for Secret Managers ### 1. **HashiCorp Vault** (Most Popular) - **Docker Image**: `hashicorp/vault:latest` or `hashicorp/vault:1.15.0` - **GitHub**: https://github.com/hashicorp/vault - **Features**: - Dynamic secrets generation - Encryption as a Service - Access control and audit logging - Multiple storage backends - RESTful API - **Best for**: Production-grade secret management ### 2. **Infisical** - **Docker Image**: Available via Docker Hub (check official docs) - **GitHub**: https://github.com/Infisical/infisical - **Features**: - End-to-end encryption - Developer-friendly UI - Sync secrets across environments - Integrations with Docker, Kubernetes, AWS - **Best for**: Developer-focused secret management ### 3. **Doppler** - **Docker Image**: `dopplerhq/doppler:latest` - **GitHub**: https://github.com/DopplerHQ - **Features**: - Simple CLI and API - Environment variable management - Sync with config files - **Best for**: Simple secret injection ### 4. **Bitwarden (Self-Hosted)** - **Docker Image**: `bitwarden/self-host:latest` - **GitHub**: https://github.com/bitwarden/server - **Features**: - Open source password manager - API access - Self-hosted option - **Best for**: Password and credential storage ### 5. **Mozilla SOPS** (Secrets OPerationS) - **Docker Image**: Available via `mozilla/sops:latest` - **GitHub**: https://github.com/mozilla/sops - **Features**: - Encrypts YAML, JSON, ENV files - Works with Git - Multiple encryption backends - **Best for**: Encrypting configuration files ### 6. **Docker Secrets** (Built-in) - **Native Docker Feature** (Docker Swarm mode) - **Features**: - Built into Docker - Encrypted at rest - Only accessible to authorized services - **Best for**: Docker Swarm deployments ## Recommended: HashiCorp Vault For production microservices, **HashiCorp Vault** is the most mature and feature-rich option. ### Quick Start with Vault ```yaml # docker-compose.yml addition vault: image: hashicorp/vault:1.15.0 container_name: vault ports: - "8200:8200" environment: VAULT_DEV_ROOT_TOKEN_ID: "myroot" # Change in production! VAULT_DEV_LISTEN_ADDRESS: "0.0.0.0:8200" cap_add: - IPC_LOCK volumes: - vault-data:/vault/data command: vault server -dev volumes: vault-data: ``` ### Production Vault Setup For production, use file storage backend: ```yaml vault: image: hashicorp/vault:1.15.0 container_name: vault ports: - "8200:8200" environment: VAULT_ADDR: "http://0.0.0.0:8200" cap_add: - IPC_LOCK volumes: - vault-config:/vault/config - vault-data:/vault/data - vault-logs:/vault/logs command: vault server -config=/vault/config/vault.hcl volumes: vault-config: vault-data: vault-logs: ``` ### Using Vault with Your Services #### Method 1: Environment Variable Injection ```python # In your service code import requests import os VAULT_ADDR = os.getenv('VAULT_ADDR', 'http://vault:8200') VAULT_TOKEN = os.getenv('VAULT_TOKEN') def get_secret(path): response = requests.get( f"{VAULT_ADDR}/v1/{path}", headers={"X-Vault-Token": VAULT_TOKEN} ) return response.json()['data']['data'] # Usage db_password = get_secret('secret/data/usermanagement/db')['password'] ``` #### Method 2: Vault Agent Sidecar Run a Vault Agent as a sidecar container that injects secrets as environment variables or files. #### Method 3: Vault CLI in Init Container Use Vault CLI in an init container to fetch secrets before the main service starts. ## Integration Example ### Adding Vault to Your docker-compose.yml ```yaml services: # ... existing services ... vault: image: hashicorp/vault:1.15.0 container_name: vault ports: - "8200:8200" environment: VAULT_DEV_ROOT_TOKEN_ID: "dev-root-token" VAULT_DEV_LISTEN_ADDRESS: "0.0.0.0:8200" cap_add: - IPC_LOCK volumes: - vault-data:/vault/data command: vault server -dev networks: - default volumes: # ... existing volumes ... vault-data: ``` ### Accessing Vault from Services Update your service environment: ```yaml usermanagement-service: # ... existing config ... environment: - VAULT_ADDR=http://vault:8200 - VAULT_TOKEN=${VAULT_TOKEN} - DATABASE_URL=${DATABASE_URL} depends_on: - vault - registration-db ``` ## Security Best Practices 1. **Never commit secrets** to version control 2. **Use environment variables** for Vault tokens in production 3. **Rotate secrets** regularly 4. **Use least privilege** access policies 5. **Enable audit logging** in production 6. **Use TLS** for Vault communication in production 7. **Store Vault tokens** securely (not in code) ## Alternative: Docker Secrets (Docker Swarm) If using Docker Swarm: ```bash # Create a secret echo "my-secret-password" | docker secret create db_password - # Use in docker-compose.yml services: usermanagement-service: secrets: - db_password environment: - DB_PASSWORD_FILE=/run/secrets/db_password secrets: db_password: external: true ``` ## Comparison Table | Solution | Complexity | Production Ready | Docker Integration | Best Use Case | |----------|-----------|------------------|-------------------|---------------| | HashiCorp Vault | High | Yes | Excellent | Enterprise/Production | | Infisical | Medium | Yes | Good | Developer teams | | Doppler | Low | Yes | Good | Simple secret injection | | Docker Secrets | Low | Swarm only | Native | Docker Swarm deployments | | SOPS | Low | Yes | Manual | File encryption | ## Recommended Approach For your microservices architecture, I recommend: 1. **Development**: Use HashiCorp Vault in dev mode (simple setup) 2. **Production**: Use HashiCorp Vault with proper configuration, TLS, and HA setup 3. **Alternative**: Use Infisical if you prefer a more developer-friendly UI 